\documentclass[a4paper,12pt]{article}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{graphicx}
\usepackage{geometry}
\usepackage{titling}
\usepackage{hyperref}
\usepackage{array}
\usepackage{parskip}
\usepackage{booktabs}
\usepackage{listings}
\usepackage{array}
\usepackage{xcolor}
\usepackage{enumitem}
\usepackage[backend=biber,style=numeric]{biblatex}
\addbibresource{bibliografia.bib}
\geometry{margin=2.5cm}

\lstdefinestyle{javascript}{
    language=Java,
    basicstyle=\ttfamily\footnotesize,
    keywordstyle=\color{blue},
    commentstyle=\color{green},
    stringstyle=\color{red},
    numbers=left,
    numberstyle=\tiny\color{gray},
    breaklines=true,
    frame=single,
    showspaces=false,
    showstringspaces=false,
    tabsize=2,
    upquote=true,
    columns=fixed,
    basewidth=0.5em
}

\title{Documentación de la api Docker}
\author{Andrea Sofía Pais Dos Santos}
\date{\today}

\begin{document}
\setlength{\droptitle}{0.4\textheight} 
\maketitle
\thispagestyle{empty}
\newpage 


\vspace{5cm}
\section{Índice}

\begin{enumerate}[start=2]
    \item Creación de la API con base de datos local ................................... página 3
    \item Creación de la imagen .................................................................... página 6
    \item Subir la imagen a DockerHub ......................................................... página 8
    \item GitHub Actions .............................................................................. página 9
    \item Notificación Action ........................................................................ página 12
    
\end{enumerate}
\newpage

\section{Creación de la API con base de datos local}

Para construir una API con MongoDB Local usando docker, primero vamos a inicializar el proyecto "npm init -y" y crear, por ahora, la siguiente estructura de carpetas y archivos. Luego para la creación de una imagen vamos a tener que crear otros documentos extras.


\vspace{0.5cm}
\begin{center}
    \includegraphics{images/Dockercarpetas.png}
\end{center}

Desglose de los archivos necesarios junto a su contenido.

\begin{itemize}
    \item Archivo index.js, contiene las importaciones y la conexión a la base de datos:
\begin{lstlisting}[style=javascript]
import express from "express";
import cors from "cors";
import dotenv from "dotenv";
import mongoose from "mongoose";
import rutas from "./rutas/rutas.js";

dotenv.config();
const app = express();
app.use(cors());
app.use(express.json());

app.use(rutas);
const uri = process.env.MONGO_URI;
export async function conectarBD(){
    try{
        await mongoose.connect(uri,{});
        console.log("Base de datos conectada");
    }catch(error){
        console.log("Error conectandose a la base de datos", error);
    }
}

const PORT = process.env.PORT || 3000;

conectarBD().then(async () => {
    app.listen(PORT, () => console.log(`API en ${PORT}`));
});
\end{lstlisting}
    \item Archivo rutas.js, está compuesto por los EndPoints (GET,POST). GET para obtener los usuarios y los grupos y POST para crear esos usuarios y grupos.
\begin{lstlisting}[style=javascript]
import express from "express";
import Usuario from "../modelos/usuarios.js";
import Grupo from "../modelos/grupos.js";

const router = express.Router();

router.get("/usuarios", async (req, res) => {
  const usuarios = await Usuario.find();
  res.json(usuarios);
});

router.get("/grupos", async (req, res) => {
  const grupos = await Grupo.find();
  res.json(grupos);
});

router.post("/usuarios", async (req, res) => {
  const nuevoUsuario = new Usuario(req.body);
  await nuevoUsuario.save();
  res.json(nuevoUsuario);
});

router.post("/grupos", async (req, res) => {
  const nuevoGrupo = new Grupo(req.body);
  await nuevoGrupo.save();
  res.json(nuevoGrupo);
});

router.get("/", (req, res) => {
  res.json({ mensaje: "API funcionando correctamente" });
});

export default router;
\end{lstlisting}
    \item Carpeta "modelos" con grupos.js y usuarios,js, que contienen el esquema con las propiedades de ambos elementos.
\begin{lstlisting}[style=javascript]
\\\\\\\\\\\\\\\\\\\\\ Archivo grupos \\\\\\\\\\\\\\\\\\\\\\\\\\
import mongoose from "mongoose";

const GrupoEschema = new mongoose.Schema({
    nombre_grupo: { 
        type: String, 
        required: true 
    },
    participantes: { 
        type: Array, 
        required: true 
    }
});

export default mongoose.model("Grupo", GrupoEschema);



\\\\\\\\\\\\\\\\\\\\\ Archivo usuarios \\\\\\\\\\\\\\\\\\\\\\\\\\

import mongoose from "mongoose";

const UsuarioEschema = new mongoose.Schema({
    nombre_user: { 
        type: String, 
        required: true 
    },
    apellido_user: { 
        type: String, 
        required: true 
    },
    edad_user: { 
        type: Number, 
        required: true 
    },
    dni_user : {
        type: String, 
        required: true 
    }
});

export default mongoose.model("Usuario", UsuarioEschema);
\end{lstlisting}    
    \item Archivo .env es el archivo de configuración que almacena datos delicados y el puerto que usaremos en este caso el 3000.
\begin{lstlisting}[style=javascript]
MONGO_URI=mongodb://<nombre>:<contrasena>@localhost:27017/mi_base_datos?admin
PORT=3000
\end{lstlisting}
    \item Archivo docker-compose.yml contiene unos servicios definidos, servicio "api"(nuestra aplicación) y servicio "db"(la base de datos MongoDB).
\begin{lstlisting}[style=javascript]
version: '3.8'

services:
  api:
    image: ejemplo-api:v1.0.0
    ports: 
      - "3000:3000"
    environment:
      - MONGO_URI=mongodb://nombre:contrasena@db:27017/admin
    depends_on:
      - db
  db:
    image: mongo:latest
    ports:
      - "27017:27017"
    environment:
      - MONGO_INITDB_ROOT_USERNAME=nombre
      - MONGO_INITDB_ROOT_PASSWORD=contrasena
    volumes:
      - mongo_data:/data/db
    restart: unless-stopped

volumes:
  mongo_data:
\end{lstlisting}
\end{itemize}

Tras tener la API estructurada, la construimos con el siguiente comando: 

\begin{lstlisting}[style=javascript]
docker-compoose up
\end{lstlisting}

Ahora en Docker deberíamos de ver al API creada.

\begin{center}
    \includegraphics[height=2cm]{images/docker3.png}
\end{center}

Hay que acordarse de que para utilizarlos hay que importar todo lo necesario, con el siguiente comando: 
\begin{lstlisting}[style=javascript]
npm install express mongoose .... "todo lo que necesitemos"
\end{lstlisting}

\vspace{2cm}
\section{Creación de la imagen}

Para la construcción de la nueva imagen creamos los siguientes archivos y modificamos el docker-compose.yml.
\begin{itemize}
    \item Archivo Dockerfile va a contener las instrucciones que sirven para crear la imagen.
\begin{lstlisting}[style=javascript]
FROM node:20
WORKDIR /app
COPY package*.json ./
RUN npm install --production
COPY . .
EXPOSE 3000
CMD ["node","index.js"]
\end{lstlisting}
Lo que nos quiere cedir esto es que desde node vamos a crear "app" que es donde vamos a trabajar desde ahora, se copiará el package*.json, va a ejecutar esa instalación compiando todo en el puerto 300.
    \item Archivo .dockerignore va a ignorar archivos pesados e información sensible.
\begin{lstlisting}[style=javascript]
node_modules
npm-debug.log
.git
.gitignore
.env
docker-compose.yml
\end{lstlisting}
\end{itemize}

Tras tener esos archivos y hayamos modificado el docker-compose cambiando el nombre de la imagen, vamos a construir la imagen, para ellos usamos el siguiente comando: 
\begin{lstlisting}[style=javascript]
docker build -t ejemplo-api:v1.0.0 .
\end{lstlisting}

\begin{center}
    \includegraphics[height=12cm]{images/docker1.png}
\end{center}

Ahora al acceder a docker, en images tendremos lo siguiente: 
\begin{center}
    \includegraphics[height=1.3cm]{images/docker2.png}
\end{center}


\vspace{8cm}
\section{Subir la imagen a DockerHub}
Para subir la imagen a DockerHub, lo primero es tener una cuenta e iniciar sesión. Tras iniciar sesión, creamos un repositorio con el nombre que queramos. 

\begin{center}
    \includegraphics[height=5.5cm]{images/docker5.png}
\end{center}

Y desde la terminal, ejecutamos el siguiente comando para que suba la imagen:  
\begin{lstlisting}[style=javascript]
docker push andreasofia31/api_docker:v1.0.0
\end{lstlisting}

Si está correctamente subida, en el repositorio de DockerHub debería salir la imagen que hemos creada:

\begin{center}
    \includegraphics[height=7cm]{images/docker6.png}
\end{center}


\vspace{7cm}
\section{GitHub Actions}

Vamos a crear un workflow de GitHub Actions que automatiza la construcción y publicación de imágenes Docker. Para ellos vamos a añadir una carpeta ".github" con una subcarpeta llamada "workflows" en ella vamos crear el archivo "docker-push.yml".

En el archivo que creamos vamos a añadir el siguiente código que va a ejecutarse desde el repositiorio al pushear cada cambio. Y va a tener la siguiente información:
\begin{itemize}
  \item Push Automático que afecta a la rama u al cualquier cambio en el repositorio.
  \item Variables de entorno que se almacenan en GitHub Secrets, que necesitaremos "DOCKER USERNAME" y "DOCKER PASSWORD".
  \item Luego todos los trabajos que va a tener que realizar ejecutando e un servidor Ubuntu. 
\end{itemize}

\vspace{1cm}
\begin{lstlisting}[style=javascript]
name: Build and Push Docker Image

on:
  push:
    branches:
      - main
      - master
    paths:
      - './**'
      - '.github/workflows/docker-push.yml'
  workflow_dispatch: # Permite ejecutar manualmente

env:
  DOCKER_IMAGE_NAME: ${{ secrets.DOCKER_USERNAME }}/api_docker
  DOCKER_TAG: latest

jobs:
  build-and-push:
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout codigo
        uses: actions/checkout@v4

      - name: Configurar Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Login a Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKER_USERNAME }}
          password: ${{ secrets.DOCKER_PASSWORD }}

      - name: Construir y subir imagen Docker
        uses: docker/build-push-action@v5
        with:
          context: ./
          file: ./Dockerfile
          push: true
          tags: ${{ env.DOCKER_IMAGE_NAME }}:${{ env.DOCKER_TAG }}
          cache-from: type=registry,ref=${{ env.DOCKER_IMAGE_NAME }}:buildcache
          cache-to: type=inline

      - name: Mostrar informacion de la imagen
        run: |
          echo "Imagen construida y subida exitosamente:"
          echo "  - Imagen: ${{ env.DOCKER_IMAGE_NAME }}:${{ env.DOCKER_TAG }}"
          echo "  - Docker Hub: https://hub.docker.com/r/${{ secrets.DOCKER_USERNAME }}/api_docker"
\end{lstlisting}

\subsection{Requisitos previos}
Acceder al repositorio de GitHub donde tengamos el poryecto subido. Dirigirnos configuraciones de repositiorio y buscar el apartado de "Secrets and variables" ahí añadimos el nombre de las variables de entorno con sus declaraciones. En este caso,
para usuario ponemos el nuestro de dockerHub y como contraseña usamos un tocken creado en DockerHub para poder acceder. 

\vspace{1cm}
\begin{center}
  \includegraphics[height=9cm]{images/docker8.png}
\end{center}
\vspace{1cm}

Si están correctamente creadas y el archivo está correcto, al pushear los nuevos cambios debería aparecer en el repositorio de GitHub un apartado llamado Actions. Y en el vemos que se ejecutó el workflow.

\vspace{1cm}
\begin{center}
  \includegraphics[height=5cm]{images/docker9.png}
\end{center}

Y dentro vemos todos los servicios realizados con éxito.

\begin{center}
  \includegraphics[height=9cm]{images/docker10.png}
\end{center}

Por último para ver que todo está correcto, vamos a DockerHub y debería salir la imagen actualizada.

\begin{center}
  \includegraphics[height=7cm]{images/docker11.png}
\end{center}

\end{document}